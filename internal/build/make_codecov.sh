#!/bin/sh
# shellcheck disable=SC1007,SC3043 # empty assignments and local usage
#
# make_codecov.sh - Generate Codecov configuration for monorepo coverage
#
# This script generates an upload script for Codecov integration that
# handles uploading coverage files with proper module flags for monorepo
# support.
#
# Usage: make_codecov.sh [index_file] [coverage_dir]
#
# Arguments:
#   index_file   - Path to the index file containing module information
#                  (default: .tmp/index)
#   coverage_dir - Directory containing coverage files
#                  (default: .coverage)
#
# Output files:
#   ${coverage_dir}/codecov.sh - Upload script for CI

set -eu

INDEX="${1:-.tmp/index}"
COVERAGE_DIR="${2:-.coverage}"

# Function to generate upload script for CI
generate_upload_script() {
	local index="$1"

	cat <<'EOF'
#!/bin/sh
# Generated by make_codecov.sh - DO NOT EDIT
# shellcheck disable=SC1007,SC3043 # empty assignments and local usage
# This script uploads each coverage file to Codecov with its module flag

set -eu

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

has_coverage() {
	local file="$1"
	local lines=

	if [ -s "$file" ]; then
		lines="$(wc -l < "$file" 2> /dev/null)"
	fi

	test "${lines:-0}" -gt 1
}

# Select best coverage file (prefer self-coverage when meaningful)
select_best_coverage() {
	local name="$1"
	local self_profile="${SCRIPT_DIR}/coverage_${name}_self.prof"
	local full_profile="${SCRIPT_DIR}/coverage_${name}.prof"

	if has_coverage "$self_profile"; then
		echo "$self_profile:self"
	elif has_coverage "$full_profile"; then
		echo "$full_profile:integration"
	else
		echo ":none"
	fi
}

upload_best_coverage() {
	local name="$1"
	local best best_file best_type

	# Select best coverage for $name
	best=$(select_best_coverage "$name")
	best_file="${best%:*}"
	best_type="${best#*:}"

	if [ "$best_type" != "none" ]; then
		echo "::group::Upload $best_type coverage for $name"
		"$CODECOV_BIN" upload-process \
			--disable-search \
			--fail-on-error \
			--file "$best_file" \
			--flag "$name"
		echo "::endgroup::"
	else
		echo "warning: no meaningful coverage found for $name" >&2
	fi
}

# Download codecov CLI with integrity check
CODECOV_BIN="${SCRIPT_DIR}/codecov"
if [ ! -f "$CODECOV_BIN" ]; then
	echo "Downloading codecov CLI..."
	curl -o "${CODECOV_BIN}" -s https://cli.codecov.io/latest/linux/codecov
	curl -o "${CODECOV_BIN}.SHA256SUM" -s https://cli.codecov.io/latest/linux/codecov.SHA256SUM
	curl -o "${CODECOV_BIN}.SHA256SUM.sig" -s https://cli.codecov.io/latest/linux/codecov.SHA256SUM.sig

	# Verify checksum
	if command -v sha256sum >/dev/null 2>&1; then
		echo "Verifying codecov checksum..."
		(cd "$SCRIPT_DIR" && sha256sum -c codecov.SHA256SUM) || {
			echo "Error: Codecov checksum verification failed" >&2
			rm -f "$CODECOV_BIN" "${CODECOV_BIN}.SHA256SUM" "${CODECOV_BIN}.SHA256SUM.sig"
			exit 1
		}
	else
		echo "Warning: sha256sum not found, skipping integrity check" >&2
	fi

	# Clean up verification files
	rm -f "${CODECOV_BIN}.SHA256SUM" "${CODECOV_BIN}.SHA256SUM.sig"

	# And schedule removal
	trap 'rm -f "$CODECOV_BIN"' EXIT
fi

chmod +x "$CODECOV_BIN"
EOF

	cat <<EOF

# Upload each coverage file with its flag
for name in $(cut -d: -f1 "$index" | tr '\n' ' '); do
	upload_best_coverage "\$name"
done
EOF
}

if [ ! -s "$INDEX" ]; then
	echo "Error: Index file not found: $INDEX" >&2
	echo "Run 'make .tmp/index' first" >&2
	exit 1
fi

# Create coverage directory
mkdir -p "$COVERAGE_DIR"

generate_upload_script "$INDEX" > "$COVERAGE_DIR/codecov.sh"
chmod +x "$COVERAGE_DIR/codecov.sh"
