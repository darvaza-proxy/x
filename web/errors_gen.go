package web

// Code generated by ./errors_gen.sh; DO NOT EDIT

//go:generate ./errors_gen.sh

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"darvaza.org/x/fs"
	"darvaza.org/x/web/consts"
)

// NewStatusMovedPermanently returns a 301 redirect error.
func NewStatusMovedPermanently(dest string, args ...any) *HTTPError {
	if len(args) > 0 {
		dest = fmt.Sprintf(dest, args...)
	}

	trailing := strings.HasSuffix(dest, "/")
	dest, _ = fs.Clean(dest)
	if trailing && !strings.HasSuffix(dest, "/") {
		dest += "/"
	}

	return &HTTPError{
		Code: http.StatusMovedPermanently,
		Hdr: http.Header{
			consts.Location: []string{dest},
		},
	}
}

// NewStatusFound returns a 302 redirect error.
func NewStatusFound(dest string, args ...any) *HTTPError {
	if len(args) > 0 {
		dest = fmt.Sprintf(dest, args...)
	}

	trailing := strings.HasSuffix(dest, "/")
	dest, _ = fs.Clean(dest)
	if trailing && !strings.HasSuffix(dest, "/") {
		dest += "/"
	}

	return &HTTPError{
		Code: http.StatusFound,
		Hdr: http.Header{
			consts.Location: []string{dest},
		},
	}
}

// NewStatusSeeOther returns a 303 redirect error.
func NewStatusSeeOther(dest string, args ...any) *HTTPError {
	if len(args) > 0 {
		dest = fmt.Sprintf(dest, args...)
	}

	trailing := strings.HasSuffix(dest, "/")
	dest, _ = fs.Clean(dest)
	if trailing && !strings.HasSuffix(dest, "/") {
		dest += "/"
	}

	return &HTTPError{
		Code: http.StatusSeeOther,
		Hdr: http.Header{
			consts.Location: []string{dest},
		},
	}
}

// NewStatusTemporaryRedirect returns a 307 redirect error.
func NewStatusTemporaryRedirect(dest string, args ...any) *HTTPError {
	if len(args) > 0 {
		dest = fmt.Sprintf(dest, args...)
	}

	trailing := strings.HasSuffix(dest, "/")
	dest, _ = fs.Clean(dest)
	if trailing && !strings.HasSuffix(dest, "/") {
		dest += "/"
	}

	return &HTTPError{
		Code: http.StatusTemporaryRedirect,
		Hdr: http.Header{
			consts.Location: []string{dest},
		},
	}
}

// NewStatusPermanentRedirect returns a 308 redirect error.
func NewStatusPermanentRedirect(dest string, args ...any) *HTTPError {
	if len(args) > 0 {
		dest = fmt.Sprintf(dest, args...)
	}

	trailing := strings.HasSuffix(dest, "/")
	dest, _ = fs.Clean(dest)
	if trailing && !strings.HasSuffix(dest, "/") {
		dest += "/"
	}

	return &HTTPError{
		Code: http.StatusPermanentRedirect,
		Hdr: http.Header{
			consts.Location: []string{dest},
		},
	}
}

// NewStatusBadRequest returns a 400 HTTP error,
// unless the given error is already qualified.
func NewStatusBadRequest(err error) *HTTPError {
	if e, ok := err.(*HTTPError); ok {
		return e
	}

	return &HTTPError{
		Code: http.StatusBadRequest,
		Err:  err,
	}
}

// NewStatusUnsupportedMediaType returns a 415 HTTP error,
// unless the given error is already qualified.
func NewStatusUnsupportedMediaType(err error) *HTTPError {
	if e, ok := err.(*HTTPError); ok {
		return e
	}

	return &HTTPError{
		Code: http.StatusUnsupportedMediaType,
		Err:  err,
	}
}

// NewStatusUnprocessableEntity returns a 422 HTTP error,
// unless the given error is already qualified.
func NewStatusUnprocessableEntity(err error) *HTTPError {
	if e, ok := err.(*HTTPError); ok {
		return e
	}

	return &HTTPError{
		Code: http.StatusUnprocessableEntity,
		Err:  err,
	}
}

// NewStatusInternalServerError returns a 500 HTTP error,
// unless the given error is already qualified.
func NewStatusInternalServerError(err error) *HTTPError {
	if e, ok := err.(*HTTPError); ok {
		return e
	}

	return &HTTPError{
		Code: http.StatusInternalServerError,
		Err:  err,
	}
}

// NewStatusBadGateway returns a 502 HTTP error,
// unless the given error is already qualified.
func NewStatusBadGateway(err error) *HTTPError {
	if e, ok := err.(*HTTPError); ok {
		return e
	}

	return &HTTPError{
		Code: http.StatusBadGateway,
		Err:  err,
	}
}

// NewStatusTooManyRequests returns a 429 HTTP error with Retry-After header.
// The retryAfter duration is rounded up to the nearest second.
func NewStatusTooManyRequests(retryAfter time.Duration) *HTTPError {
	hdr := make(http.Header)
	SetRetryAfter(hdr, retryAfter)

	return &HTTPError{
		Code: http.StatusTooManyRequests,
		Hdr:  hdr,
	}
}

// NewStatusServiceUnavailable returns a 503 HTTP error with Retry-After header.
// The retryAfter duration is rounded up to the nearest second.
func NewStatusServiceUnavailable(retryAfter time.Duration) *HTTPError {
	hdr := make(http.Header)
	SetRetryAfter(hdr, retryAfter)

	return &HTTPError{
		Code: http.StatusServiceUnavailable,
		Hdr:  hdr,
	}
}

// NewStatusNotModified returns a 304 HTTP error.
func NewStatusNotModified() *HTTPError {
	return &HTTPError{
		Code: http.StatusNotModified,
	}
}

// NewStatusUnauthorized returns a 401 HTTP error.
func NewStatusUnauthorized() *HTTPError {
	return &HTTPError{
		Code: http.StatusUnauthorized,
	}
}

// NewStatusForbidden returns a 403 HTTP error.
func NewStatusForbidden() *HTTPError {
	return &HTTPError{
		Code: http.StatusForbidden,
	}
}

// NewStatusNotFound returns a 404 HTTP error.
func NewStatusNotFound() *HTTPError {
	return &HTTPError{
		Code: http.StatusNotFound,
	}
}

// NewStatusNotAcceptable returns a 406 HTTP error.
func NewStatusNotAcceptable() *HTTPError {
	return &HTTPError{
		Code: http.StatusNotAcceptable,
	}
}

// NewStatusConflict returns a 409 HTTP error.
func NewStatusConflict() *HTTPError {
	return &HTTPError{
		Code: http.StatusConflict,
	}
}

// NewStatusGone returns a 410 HTTP error.
func NewStatusGone() *HTTPError {
	return &HTTPError{
		Code: http.StatusGone,
	}
}

// NewStatusPreconditionFailed returns a 412 HTTP error.
func NewStatusPreconditionFailed() *HTTPError {
	return &HTTPError{
		Code: http.StatusPreconditionFailed,
	}
}

// NewStatusNotImplemented returns a 501 HTTP error.
func NewStatusNotImplemented() *HTTPError {
	return &HTTPError{
		Code: http.StatusNotImplemented,
	}
}

// NewStatusGatewayTimeout returns a 504 HTTP error.
func NewStatusGatewayTimeout() *HTTPError {
	return &HTTPError{
		Code: http.StatusGatewayTimeout,
	}
}
