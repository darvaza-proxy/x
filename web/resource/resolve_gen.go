package resource

// Code generated by ./resolve_gen.sh; DO NOT EDIT

//go:generate ./resolve_gen.sh

import (
	"darvaza.org/core"
	"darvaza.org/x/web/forms"
)

// RouteParamValueFirstSigned attempts to a parse a string parameter into a [core.Signed] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueFirstSigned[T core.Signed](t RouteParamsTable, key string,
	base int) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseSigned[T](s, base)
	}
	return value, found, err
}

// RouteParamValueFirstSignedInRange attempts to a parse a string parameter into a [core.Signed] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueFirstSignedInRange[T core.Signed](t RouteParamsTable, key string, base int,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseSignedInRange[T](s,
			base, minV, maxV)
	}
	return value, found, err
}

// RouteParamValueLastSigned attempts to a parse a string parameter into a [core.Signed] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueLastSigned[T core.Signed](t RouteParamsTable, key string,
	base int) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseSigned[T](s, base)
	}
	return value, found, err
}

// RouteParamValueLastSignedInRange attempts to a parse a string parameter into a [core.Signed] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueLastSignedInRange[T core.Signed](t RouteParamsTable, key string, base int,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseSignedInRange[T](s,
			base, minV, maxV)
	}
	return value, found, err
}

// RouteParamValueAllSigned attempts to a parse a string values of a parameter
// into [core.Signed] values, and indicator if the parameter was present,
// and potentially a parse error of [strconv.NumError] type.
func RouteParamValueAllSigned[T core.Signed](t RouteParamsTable, key string,
	base int) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseSigned[T](s, base)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueAllSignedInRange attempts to a parse a string values of a parameter
// into [core.Signed] values and verify they are within the given boundaries.
// It also returns and indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueAllSignedInRange[T core.Signed](t RouteParamsTable, key string, base int,
	minV, maxV T) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseSignedInRange[T](s,
				base, minV, maxV)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueFirstUnsigned attempts to a parse a string parameter into a [core.Unsigned] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueFirstUnsigned[T core.Unsigned](t RouteParamsTable, key string,
	base int) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseUnsigned[T](s, base)
	}
	return value, found, err
}

// RouteParamValueFirstUnsignedInRange attempts to a parse a string parameter into a [core.Unsigned] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueFirstUnsignedInRange[T core.Unsigned](t RouteParamsTable, key string, base int,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseUnsignedInRange[T](s,
			base, minV, maxV)
	}
	return value, found, err
}

// RouteParamValueLastUnsigned attempts to a parse a string parameter into a [core.Unsigned] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueLastUnsigned[T core.Unsigned](t RouteParamsTable, key string,
	base int) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseUnsigned[T](s, base)
	}
	return value, found, err
}

// RouteParamValueLastUnsignedInRange attempts to a parse a string parameter into a [core.Unsigned] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueLastUnsignedInRange[T core.Unsigned](t RouteParamsTable, key string, base int,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseUnsignedInRange[T](s,
			base, minV, maxV)
	}
	return value, found, err
}

// RouteParamValueAllUnsigned attempts to a parse a string values of a parameter
// into [core.Unsigned] values, and indicator if the parameter was present,
// and potentially a parse error of [strconv.NumError] type.
func RouteParamValueAllUnsigned[T core.Unsigned](t RouteParamsTable, key string,
	base int) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseUnsigned[T](s, base)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueAllUnsignedInRange attempts to a parse a string values of a parameter
// into [core.Unsigned] values and verify they are within the given boundaries.
// It also returns and indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueAllUnsignedInRange[T core.Unsigned](t RouteParamsTable, key string, base int,
	minV, maxV T) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseUnsignedInRange[T](s,
				base, minV, maxV)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueFirstFloat attempts to a parse a string parameter into a [core.Float] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueFirstFloat[T core.Float](t RouteParamsTable, key string) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseFloat[T](s)
	}
	return value, found, err
}

// RouteParamValueFirstFloatInRange attempts to a parse a string parameter into a [core.Float] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueFirstFloatInRange[T core.Float](t RouteParamsTable, key string,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseFloatInRange[T](s,
			minV, maxV)
	}
	return value, found, err
}

// RouteParamValueLastFloat attempts to a parse a string parameter into a [core.Float] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueLastFloat[T core.Float](t RouteParamsTable, key string) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseFloat[T](s)
	}
	return value, found, err
}

// RouteParamValueLastFloatInRange attempts to a parse a string parameter into a [core.Float] value,
// and verify they are within the given boundaries.
// It also returns an indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueLastFloatInRange[T core.Float](t RouteParamsTable, key string,
	minV, maxV T) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseFloatInRange[T](s,
			minV, maxV)
	}
	return value, found, err
}

// RouteParamValueAllFloat attempts to a parse a string values of a parameter
// into [core.Float] values, and indicator if the parameter was present,
// and potentially a parse error of [strconv.NumError] type.
func RouteParamValueAllFloat[T core.Float](t RouteParamsTable, key string) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseFloat[T](s)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueAllFloatInRange attempts to a parse a string values of a parameter
// into [core.Float] values and verify they are within the given boundaries.
// It also returns and indicator if the parameter was present,
// and potentially an error of [strconv.NumError] type.
func RouteParamValueAllFloatInRange[T core.Float](t RouteParamsTable, key string,
	minV, maxV T) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseFloatInRange[T](s,
				minV, maxV)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}

// RouteParamValueFirstBool attempts to a parse a string parameter into a [core.Bool] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueFirstBool[T core.Bool](t RouteParamsTable, key string) (value T, found bool, err error) {
	//
	s, found := RouteParamFirst[string](t, key)
	if found {
		value, err = forms.ParseBool[T](s)
	}
	return value, found, err
}

// RouteParamValueLastBool attempts to a parse a string parameter into a [core.Bool] value, if the parameter
// was present, and potentially a parse error of [strconv.NumError] type.
func RouteParamValueLastBool[T core.Bool](t RouteParamsTable, key string) (value T, found bool, err error) {
	//
	s, found := RouteParamLast[string](t, key)
	if found {
		value, err = forms.ParseBool[T](s)
	}
	return value, found, err
}

// RouteParamValueAllBool attempts to a parse a string values of a parameter
// into [core.Bool] values, and indicator if the parameter was present,
// and potentially a parse error of [strconv.NumError] type.
func RouteParamValueAllBool[T core.Bool](t RouteParamsTable, key string) (values []T, found bool, err error) {
	//
	ss, found := RouteParamAll[string](t, key)
	if found {
		values = make([]T, 0, len(ss))
		for _, s := range ss {
			v, err := forms.ParseBool[T](s)
			if err != nil {
				return values, true, err
			}
			values = append(values, v)
		}
	}
	return values, found, nil
}
