#!/bin/sh

set -eu

TAG=go:generate

exec > "$GOFILE~"

to_upper() {
	if [ $# -gt 0 ]; then
		echo "$@"
	else
		cat
	fi | tr '[:lower:]' '[:upper:]'
}

to_lower() {
	if [ $# -gt 0 ]; then
		echo "$@"
	else
		cat
	fi | tr '[:upper:]' '[:lower:]'
}

cat <<EOT
package $GOPACKAGE

// Code generated by $0; DO NOT EDIT.

//$TAG $0

import (
	"net/http"

	"darvaza.org/x/web"
)

// HandlerFunc represents a function [web.HandlerFunc] but taking a data
// parameter.
type HandlerFunc[T any] func(http.ResponseWriter, *http.Request, *T) error

// AsHandlerFunc wraps a [web.HandlerFunc] into a [HandlerFunc], discarding
// the data pointer.
func AsHandlerFunc[T any](fn web.HandlerFunc) HandlerFunc[T] {
	return func(rw http.ResponseWriter, req *http.Request, _ *T) error {
		return fn(rw, req)
	}
}
EOT

METHODS=" \
	Get:Getter \
	Head:Peeker \
	Post:Poster \
	Put:Putter \
	Delete:Deleter \
	Options:Optioner \
	Patch:Patcher \
	"

for x in $METHODS; do

fn="${x%:*}"
iface="${x#*:}"

verb="$(to_upper "$fn")"
accessor="$(to_lower "$iface")Of"

cat <<EOT

// $iface represents a resource that handles $verb requests.
type $iface interface {
	$fn(http.ResponseWriter, *http.Request) error
}

// T${iface} represents a resource that handles $verb requests with a data field.
type T${iface}[T any] interface {
	$fn(http.ResponseWriter, *http.Request, *T) error
}

func ${accessor}[T any](x any) (HandlerFunc[T], bool) {
	switch v := x.(type) {
	case T${iface}[T]:
		return v.$fn, true
	case $iface:
		return AsHandlerFunc[T](v.$fn), true
	default:
		return nil, false
	}
}
EOT
done

cat <<EOT

func addHandlers[T any](h *Resource[T], x any) {
EOT
for x in $METHODS; do
	fn="${x%:*}"
	iface="${x#*:}"
	verb="$(to_upper "$fn")"
	accessor="$(to_lower "$iface")Of"

	cat <<EOT
	// $verb
	if fn, ok := ${accessor}[T](x); ok {
		h.h[$verb] = fn
	}
EOT
done
cat <<EOT
}

const (
EOT
for x in $METHODS; do
	fn="${x%:*}"
	verb="$(to_upper "$fn")"

	cat <<EOT
	// $verb represents the HTTP $verb Method.
	$verb = "$verb"
EOT

done
echo ")"

mv "$GOFILE~" "$GOFILE"
