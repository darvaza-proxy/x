package testutils

// Code generated by ./generic_gen.sh; DO NOT EDIT

//go:generate ./generic_gen.sh

//revive:disable:flag-parameter,argument-limit,confusing-naming

import (
	"testing"

	"darvaza.org/core"
)

// GetterMethod represents a method that takes *T and returns V
type GetterMethod[T any, V comparable] func(*T) V

// GetterMethodOneArg represents a method that takes *T, one argument, and returns V
type GetterMethodOneArg[T, A1 any, V comparable] func(*T, A1) V

// GetterMethodTwoArgs represents a method that takes *T, two arguments, and returns V
type GetterMethodTwoArgs[T, A1, A2 any, V comparable] func(*T, A1, A2) V

// GetterMethodThreeArgs represents a method that takes *T, three arguments, and returns V
type GetterMethodThreeArgs[T, A1, A2, A3 any, V comparable] func(*T, A1, A2, A3) V

// GetterMethodFourArgs represents a method that takes *T, four arguments, and returns V
type GetterMethodFourArgs[T, A1, A2, A3, A4 any, V comparable] func(*T, A1, A2, A3, A4) V

// GetterMethodFiveArgs represents a method that takes *T, five arguments, and returns V
type GetterMethodFiveArgs[T, A1, A2, A3, A4, A5 any, V comparable] func(*T, A1, A2, A3, A4, A5) V

// GetterOKMethod represents a method that takes *T and returns (V, bool)
type GetterOKMethod[T any, V comparable] func(*T) (V, bool)

// GetterOKMethodOneArg represents a method that takes *T, one argument, and returns (V, bool)
type GetterOKMethodOneArg[T, A1 any, V comparable] func(*T, A1) (V, bool)

// GetterOKMethodTwoArgs represents a method that takes *T, two arguments, and returns (V, bool)
type GetterOKMethodTwoArgs[T, A1, A2 any, V comparable] func(*T, A1, A2) (V, bool)

// GetterOKMethodThreeArgs represents a method that takes *T, three arguments, and returns (V, bool)
type GetterOKMethodThreeArgs[T, A1, A2, A3 any, V comparable] func(*T, A1, A2, A3) (V, bool)

// GetterOKMethodFourArgs represents a method that takes *T, four arguments, and returns (V, bool)
type GetterOKMethodFourArgs[T, A1, A2, A3, A4 any, V comparable] func(*T, A1, A2, A3, A4) (V, bool)

// GetterOKMethodFiveArgs represents a method that takes *T, five arguments, and returns (V, bool)
type GetterOKMethodFiveArgs[T, A1, A2, A3, A4, A5 any, V comparable] func(*T, A1, A2, A3, A4, A5) (V, bool)

// GetterErrorMethod represents a method that takes *T and returns (V, error)
type GetterErrorMethod[T any, V comparable] func(*T) (V, error)

// GetterErrorMethodOneArg represents a method that takes *T, one argument, and returns (V, error)
type GetterErrorMethodOneArg[T, A1 any, V comparable] func(*T, A1) (V, error)

// GetterErrorMethodTwoArgs represents a method that takes *T, two arguments, and returns (V, error)
type GetterErrorMethodTwoArgs[T, A1, A2 any, V comparable] func(*T, A1, A2) (V, error)

// GetterErrorMethodThreeArgs represents a method that takes *T, three arguments, and returns (V, error)
type GetterErrorMethodThreeArgs[T, A1, A2, A3 any, V comparable] func(*T, A1, A2, A3) (V, error)

// GetterErrorMethodFourArgs represents a method that takes *T, four arguments, and returns (V, error)
type GetterErrorMethodFourArgs[T, A1, A2, A3, A4 any, V comparable] func(*T, A1, A2, A3, A4) (V, error)

// GetterErrorMethodFiveArgs represents a method that takes *T, five arguments, and returns (V, error)
type GetterErrorMethodFiveArgs[T, A1, A2, A3, A4, A5 any, V comparable] func(*T, A1, A2, A3, A4, A5) (V, error)

// ErrorMethod represents a method that takes *T and returns error
type ErrorMethod[T any] func(*T) error

// ErrorMethodOneArg represents a method that takes *T, one argument, and returns error
type ErrorMethodOneArg[T, A1 any] func(*T, A1) error

// ErrorMethodTwoArgs represents a method that takes *T, two arguments, and returns error
type ErrorMethodTwoArgs[T, A1, A2 any] func(*T, A1, A2) error

// ErrorMethodThreeArgs represents a method that takes *T, three arguments, and returns error
type ErrorMethodThreeArgs[T, A1, A2, A3 any] func(*T, A1, A2, A3) error

// ErrorMethodFourArgs represents a method that takes *T, four arguments, and returns error
type ErrorMethodFourArgs[T, A1, A2, A3, A4 any] func(*T, A1, A2, A3, A4) error

// ErrorMethodFiveArgs represents a method that takes *T, five arguments, and returns error
type ErrorMethodFiveArgs[T, A1, A2, A3, A4, A5 any] func(*T, A1, A2, A3, A4, A5) error

// Factory represents a function that returns *T
type Factory[T any] func() *T

// FactoryOneArg represents a function that takes one argument and returns *T
type FactoryOneArg[T, A1 any] func(A1) *T

// FactoryTwoArgs represents a function that takes two arguments and returns *T
type FactoryTwoArgs[T, A1, A2 any] func(A1, A2) *T

// FactoryThreeArgs represents a function that takes three arguments and returns *T
type FactoryThreeArgs[T, A1, A2, A3 any] func(A1, A2, A3) *T

// FactoryFourArgs represents a function that takes four arguments and returns *T
type FactoryFourArgs[T, A1, A2, A3, A4 any] func(A1, A2, A3, A4) *T

// FactoryFiveArgs represents a function that takes five arguments and returns *T
type FactoryFiveArgs[T, A1, A2, A3, A4, A5 any] func(A1, A2, A3, A4, A5) *T

// FactoryOK represents a function that returns (*T, bool)
type FactoryOK[T any] func() (*T, bool)

// FactoryOKOneArg represents a function that takes one argument and returns (*T, bool)
type FactoryOKOneArg[T, A1 any] func(A1) (*T, bool)

// FactoryOKTwoArgs represents a function that takes two arguments and returns (*T, bool)
type FactoryOKTwoArgs[T, A1, A2 any] func(A1, A2) (*T, bool)

// FactoryOKThreeArgs represents a function that takes three arguments and returns (*T, bool)
type FactoryOKThreeArgs[T, A1, A2, A3 any] func(A1, A2, A3) (*T, bool)

// FactoryOKFourArgs represents a function that takes four arguments and returns (*T, bool)
type FactoryOKFourArgs[T, A1, A2, A3, A4 any] func(A1, A2, A3, A4) (*T, bool)

// FactoryOKFiveArgs represents a function that takes five arguments and returns (*T, bool)
type FactoryOKFiveArgs[T, A1, A2, A3, A4, A5 any] func(A1, A2, A3, A4, A5) (*T, bool)

// FactoryError represents a function that returns (*T, error)
type FactoryError[T any] func() (*T, error)

// FactoryErrorOneArg represents a function that takes one argument and returns (*T, error)
type FactoryErrorOneArg[T, A1 any] func(A1) (*T, error)

// FactoryErrorTwoArgs represents a function that takes two arguments and returns (*T, error)
type FactoryErrorTwoArgs[T, A1, A2 any] func(A1, A2) (*T, error)

// FactoryErrorThreeArgs represents a function that takes three arguments and returns (*T, error)
type FactoryErrorThreeArgs[T, A1, A2, A3 any] func(A1, A2, A3) (*T, error)

// FactoryErrorFourArgs represents a function that takes four arguments and returns (*T, error)
type FactoryErrorFourArgs[T, A1, A2, A3, A4 any] func(A1, A2, A3, A4) (*T, error)

// FactoryErrorFiveArgs represents a function that takes five arguments and returns (*T, error)
type FactoryErrorFiveArgs[T, A1, A2, A3, A4, A5 any] func(A1, A2, A3, A4, A5) (*T, error)

// Function represents a function that returns V
type Function[V comparable] func() V

// FunctionOneArg represents a function that takes one argument and returns V
type FunctionOneArg[A1 any, V comparable] func(A1) V

// FunctionTwoArgs represents a function that takes two arguments and returns V
type FunctionTwoArgs[A1, A2 any, V comparable] func(A1, A2) V

// FunctionThreeArgs represents a function that takes three arguments and returns V
type FunctionThreeArgs[A1, A2, A3 any, V comparable] func(A1, A2, A3) V

// FunctionFourArgs represents a function that takes four arguments and returns V
type FunctionFourArgs[A1, A2, A3, A4 any, V comparable] func(A1, A2, A3, A4) V

// FunctionFiveArgs represents a function that takes five arguments and returns V
type FunctionFiveArgs[A1, A2, A3, A4, A5 any, V comparable] func(A1, A2, A3, A4, A5) V

// FunctionOK represents a function that returns (V, bool)
type FunctionOK[V comparable] func() (V, bool)

// FunctionOKOneArg represents a function that takes one argument and returns (V, bool)
type FunctionOKOneArg[A1 any, V comparable] func(A1) (V, bool)

// FunctionOKTwoArgs represents a function that takes two arguments and returns (V, bool)
type FunctionOKTwoArgs[A1, A2 any, V comparable] func(A1, A2) (V, bool)

// FunctionOKThreeArgs represents a function that takes three arguments and returns (V, bool)
type FunctionOKThreeArgs[A1, A2, A3 any, V comparable] func(A1, A2, A3) (V, bool)

// FunctionOKFourArgs represents a function that takes four arguments and returns (V, bool)
type FunctionOKFourArgs[A1, A2, A3, A4 any, V comparable] func(A1, A2, A3, A4) (V, bool)

// FunctionOKFiveArgs represents a function that takes five arguments and returns (V, bool)
type FunctionOKFiveArgs[A1, A2, A3, A4, A5 any, V comparable] func(A1, A2, A3, A4, A5) (V, bool)

// FunctionError represents a function that returns (V, error)
type FunctionError[V comparable] func() (V, error)

// FunctionErrorOneArg represents a function that takes one argument and returns (V, error)
type FunctionErrorOneArg[A1 any, V comparable] func(A1) (V, error)

// FunctionErrorTwoArgs represents a function that takes two arguments and returns (V, error)
type FunctionErrorTwoArgs[A1, A2 any, V comparable] func(A1, A2) (V, error)

// FunctionErrorThreeArgs represents a function that takes three arguments and returns (V, error)
type FunctionErrorThreeArgs[A1, A2, A3 any, V comparable] func(A1, A2, A3) (V, error)

// FunctionErrorFourArgs represents a function that takes four arguments and returns (V, error)
type FunctionErrorFourArgs[A1, A2, A3, A4 any, V comparable] func(A1, A2, A3, A4) (V, error)

// FunctionErrorFiveArgs represents a function that takes five arguments and returns (V, error)
type FunctionErrorFiveArgs[A1, A2, A3, A4, A5 any, V comparable] func(A1, A2, A3, A4, A5) (V, error)

// Compile-time verification that test case types implement TestCase interface.
var _ core.TestCase = (*GetterTestCase[any, int])(nil)
var _ core.TestCase = (*GetterOneArgTestCase[any, any, int])(nil)
var _ core.TestCase = (*GetterTwoArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*GetterThreeArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterFourArgsTestCase[any, any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterFiveArgsTestCase[any, any, any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterOKTestCase[any, int])(nil)
var _ core.TestCase = (*GetterOKOneArgTestCase[any, any, int])(nil)
var _ core.TestCase = (*GetterOKTwoArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*GetterOKThreeArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterOKFourArgsTestCase[any, any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterOKFiveArgsTestCase[any, any, any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterErrorTestCase[any, int])(nil)
var _ core.TestCase = (*GetterErrorOneArgTestCase[any, any, int])(nil)
var _ core.TestCase = (*GetterErrorTwoArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*GetterErrorThreeArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterErrorFourArgsTestCase[any, any, any, any, any, int])(nil)
var _ core.TestCase = (*GetterErrorFiveArgsTestCase[any, any, any, any, any, any, int])(nil)
var _ core.TestCase = (*ErrorTestCase[any])(nil)
var _ core.TestCase = (*ErrorOneArgTestCase[any, any])(nil)
var _ core.TestCase = (*ErrorTwoArgsTestCase[any, any, any])(nil)
var _ core.TestCase = (*ErrorThreeArgsTestCase[any, any, any, any])(nil)
var _ core.TestCase = (*ErrorFourArgsTestCase[any, any, any, any, any])(nil)
var _ core.TestCase = (*ErrorFiveArgsTestCase[any, any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryTestCase[any])(nil)
var _ core.TestCase = (*FactoryOneArgTestCase[any, any])(nil)
var _ core.TestCase = (*FactoryTwoArgsTestCase[any, any, any])(nil)
var _ core.TestCase = (*FactoryThreeArgsTestCase[any, any, any, any])(nil)
var _ core.TestCase = (*FactoryFourArgsTestCase[any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryFiveArgsTestCase[any, any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryOKTestCase[any])(nil)
var _ core.TestCase = (*FactoryOKOneArgTestCase[any, any])(nil)
var _ core.TestCase = (*FactoryOKTwoArgsTestCase[any, any, any])(nil)
var _ core.TestCase = (*FactoryOKThreeArgsTestCase[any, any, any, any])(nil)
var _ core.TestCase = (*FactoryOKFourArgsTestCase[any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryOKFiveArgsTestCase[any, any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryErrorTestCase[any])(nil)
var _ core.TestCase = (*FactoryErrorOneArgTestCase[any, any])(nil)
var _ core.TestCase = (*FactoryErrorTwoArgsTestCase[any, any, any])(nil)
var _ core.TestCase = (*FactoryErrorThreeArgsTestCase[any, any, any, any])(nil)
var _ core.TestCase = (*FactoryErrorFourArgsTestCase[any, any, any, any, any])(nil)
var _ core.TestCase = (*FactoryErrorFiveArgsTestCase[any, any, any, any, any, any])(nil)
var _ core.TestCase = (*FunctionTestCase[int])(nil)
var _ core.TestCase = (*FunctionOneArgTestCase[any, int])(nil)
var _ core.TestCase = (*FunctionTwoArgsTestCase[any, any, int])(nil)
var _ core.TestCase = (*FunctionThreeArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*FunctionFourArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*FunctionFiveArgsTestCase[any, any, any, any, any, int])(nil)
var _ core.TestCase = (*FunctionOKTestCase[int])(nil)
var _ core.TestCase = (*FunctionOKOneArgTestCase[any, int])(nil)
var _ core.TestCase = (*FunctionOKTwoArgsTestCase[any, any, int])(nil)
var _ core.TestCase = (*FunctionOKThreeArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*FunctionOKFourArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*FunctionOKFiveArgsTestCase[any, any, any, any, any, int])(nil)
var _ core.TestCase = (*FunctionErrorTestCase[int])(nil)
var _ core.TestCase = (*FunctionErrorOneArgTestCase[any, int])(nil)
var _ core.TestCase = (*FunctionErrorTwoArgsTestCase[any, any, int])(nil)
var _ core.TestCase = (*FunctionErrorThreeArgsTestCase[any, any, any, int])(nil)
var _ core.TestCase = (*FunctionErrorFourArgsTestCase[any, any, any, any, int])(nil)
var _ core.TestCase = (*FunctionErrorFiveArgsTestCase[any, any, any, any, any, int])(nil)

// GetterTestCase is a generic test case for testing
// getter methods that return V
type GetterTestCase[T any, V comparable] struct {
	name       string
	method     GetterMethod[T, V]
	methodName string
	item       *T
	expected   V
}

// Name returns the test case name.
func (tc GetterTestCase[T, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterTestCase[T, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterTestCase creates a new GetterTestCase instance.
func NewGetterTestCase[T any, V comparable](
	name string,
	method GetterMethod[T, V],
	methodName string,
	item *T,
	expected V,
) GetterTestCase[T, V] {
	return GetterTestCase[T, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		expected:   expected,
	}
}

// GetterOneArgTestCase is a generic test case for testing
// getter methods that return V with one argument
type GetterOneArgTestCase[T, A1 any, V comparable] struct {
	name       string
	method     GetterMethodOneArg[T, A1, V]
	methodName string
	item       *T
	arg1       A1
	expected   V
}

// Name returns the test case name.
func (tc GetterOneArgTestCase[T, A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOneArgTestCase[T, A1, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item, tc.arg1)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterOneArgTestCase creates a new GetterOneArgTestCase instance.
func NewGetterOneArgTestCase[T, A1 any, V comparable](
	name string,
	method GetterMethodOneArg[T, A1, V],
	methodName string,
	item *T,
	arg1 A1,
	expected V,
) GetterOneArgTestCase[T, A1, V] {
	return GetterOneArgTestCase[T, A1, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		expected:   expected,
	}
}

// GetterTwoArgsTestCase is a generic test case for testing
// getter methods that return V with two arguments
type GetterTwoArgsTestCase[T, A1, A2 any, V comparable] struct {
	name       string
	method     GetterMethodTwoArgs[T, A1, A2, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	expected   V
}

// Name returns the test case name.
func (tc GetterTwoArgsTestCase[T, A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterTwoArgsTestCase[T, A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item, tc.arg1, tc.arg2)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterTwoArgsTestCase creates a new GetterTwoArgsTestCase instance.
func NewGetterTwoArgsTestCase[T, A1, A2 any, V comparable](
	name string,
	method GetterMethodTwoArgs[T, A1, A2, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	expected V,
) GetterTwoArgsTestCase[T, A1, A2, V] {
	return GetterTwoArgsTestCase[T, A1, A2, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		expected:   expected,
	}
}

// GetterThreeArgsTestCase is a generic test case for testing
// getter methods that return V with three arguments
type GetterThreeArgsTestCase[T, A1, A2, A3 any, V comparable] struct {
	name       string
	method     GetterMethodThreeArgs[T, A1, A2, A3, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	expected   V
}

// Name returns the test case name.
func (tc GetterThreeArgsTestCase[T, A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterThreeArgsTestCase[T, A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterThreeArgsTestCase creates a new GetterThreeArgsTestCase instance.
func NewGetterThreeArgsTestCase[T, A1, A2, A3 any, V comparable](
	name string,
	method GetterMethodThreeArgs[T, A1, A2, A3, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
) GetterThreeArgsTestCase[T, A1, A2, A3, V] {
	return GetterThreeArgsTestCase[T, A1, A2, A3, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		expected:   expected,
	}
}

// GetterFourArgsTestCase is a generic test case for testing
// getter methods that return V with four arguments
type GetterFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable] struct {
	name       string
	method     GetterMethodFourArgs[T, A1, A2, A3, A4, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	arg4       A4
	expected   V
}

// Name returns the test case name.
func (tc GetterFourArgsTestCase[T, A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterFourArgsTestCase[T, A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterFourArgsTestCase creates a new GetterFourArgsTestCase instance.
func NewGetterFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable](
	name string,
	method GetterMethodFourArgs[T, A1, A2, A3, A4, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
) GetterFourArgsTestCase[T, A1, A2, A3, A4, V] {
	return GetterFourArgsTestCase[T, A1, A2, A3, A4, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		arg4:       arg4,
		expected:   expected,
	}
}

// GetterFiveArgsTestCase is a generic test case for testing
// getter methods that return V with five arguments
type GetterFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable] struct {
	name       string
	method     GetterMethodFiveArgs[T, A1, A2, A3, A4, A5, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	arg4       A4
	arg5       A5
	expected   V
}

// Name returns the test case name.
func (tc GetterFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	actual := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	core.AssertEqual(t, tc.expected, actual, tc.methodName)
}

// NewGetterFiveArgsTestCase creates a new GetterFiveArgsTestCase instance.
func NewGetterFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable](
	name string,
	method GetterMethodFiveArgs[T, A1, A2, A3, A4, A5, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
) GetterFiveArgsTestCase[T, A1, A2, A3, A4, A5, V] {
	return GetterFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		arg4:       arg4,
		arg5:       arg5,
		expected:   expected,
	}
}

// GetterOKTestCase is a generic test case for testing
// getter methods that return (V, bool)
type GetterOKTestCase[T any, V comparable] struct {
	name       string
	method     GetterOKMethod[T, V]
	methodName string
	item       *T
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKTestCase[T, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKTestCase[T, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKTestCase creates a new GetterOKTestCase instance.
func NewGetterOKTestCase[T any, V comparable](
	name string,
	method GetterOKMethod[T, V],
	methodName string,
	item *T,
	expected V,
	expectOK bool,
) GetterOKTestCase[T, V] {
	return GetterOKTestCase[T, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterOKOneArgTestCase is a generic test case for testing
// getter methods that return (V, bool) with one argument
type GetterOKOneArgTestCase[T, A1 any, V comparable] struct {
	name       string
	method     GetterOKMethodOneArg[T, A1, V]
	methodName string
	item       *T
	arg1       A1
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKOneArgTestCase[T, A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKOneArgTestCase[T, A1, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item, tc.arg1)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKOneArgTestCase creates a new GetterOKOneArgTestCase instance.
func NewGetterOKOneArgTestCase[T, A1 any, V comparable](
	name string,
	method GetterOKMethodOneArg[T, A1, V],
	methodName string,
	item *T,
	arg1 A1,
	expected V,
	expectOK bool,
) GetterOKOneArgTestCase[T, A1, V] {
	return GetterOKOneArgTestCase[T, A1, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterOKTwoArgsTestCase is a generic test case for testing
// getter methods that return (V, bool) with two arguments
type GetterOKTwoArgsTestCase[T, A1, A2 any, V comparable] struct {
	name       string
	method     GetterOKMethodTwoArgs[T, A1, A2, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKTwoArgsTestCase[T, A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKTwoArgsTestCase[T, A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item, tc.arg1, tc.arg2)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKTwoArgsTestCase creates a new GetterOKTwoArgsTestCase instance.
func NewGetterOKTwoArgsTestCase[T, A1, A2 any, V comparable](
	name string,
	method GetterOKMethodTwoArgs[T, A1, A2, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	expected V,
	expectOK bool,
) GetterOKTwoArgsTestCase[T, A1, A2, V] {
	return GetterOKTwoArgsTestCase[T, A1, A2, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterOKThreeArgsTestCase is a generic test case for testing
// getter methods that return (V, bool) with three arguments
type GetterOKThreeArgsTestCase[T, A1, A2, A3 any, V comparable] struct {
	name       string
	method     GetterOKMethodThreeArgs[T, A1, A2, A3, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKThreeArgsTestCase[T, A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKThreeArgsTestCase[T, A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKThreeArgsTestCase creates a new GetterOKThreeArgsTestCase instance.
func NewGetterOKThreeArgsTestCase[T, A1, A2, A3 any, V comparable](
	name string,
	method GetterOKMethodThreeArgs[T, A1, A2, A3, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
	expectOK bool,
) GetterOKThreeArgsTestCase[T, A1, A2, A3, V] {
	return GetterOKThreeArgsTestCase[T, A1, A2, A3, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterOKFourArgsTestCase is a generic test case for testing
// getter methods that return (V, bool) with four arguments
type GetterOKFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable] struct {
	name       string
	method     GetterOKMethodFourArgs[T, A1, A2, A3, A4, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	arg4       A4
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKFourArgsTestCase[T, A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKFourArgsTestCase[T, A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKFourArgsTestCase creates a new GetterOKFourArgsTestCase instance.
func NewGetterOKFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable](
	name string,
	method GetterOKMethodFourArgs[T, A1, A2, A3, A4, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
	expectOK bool,
) GetterOKFourArgsTestCase[T, A1, A2, A3, A4, V] {
	return GetterOKFourArgsTestCase[T, A1, A2, A3, A4, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		arg4:       arg4,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterOKFiveArgsTestCase is a generic test case for testing
// getter methods that return (V, bool) with five arguments
type GetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable] struct {
	name       string
	method     GetterOKMethodFiveArgs[T, A1, A2, A3, A4, A5, V]
	methodName string
	item       *T
	arg1       A1
	arg2       A2
	arg3       A3
	arg4       A4
	arg5       A5
	expected   V
	expectOK   bool
}

// Name returns the test case name.
func (tc GetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	core.AssertEqual(t, tc.expectOK, ok, tc.methodName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	}
}

// NewGetterOKFiveArgsTestCase creates a new GetterOKFiveArgsTestCase instance.
func NewGetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable](
	name string,
	method GetterOKMethodFiveArgs[T, A1, A2, A3, A4, A5, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
	expectOK bool,
) GetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5, V] {
	return GetterOKFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]{
		name:       name,
		method:     method,
		methodName: methodName,
		item:       item,
		arg1:       arg1,
		arg2:       arg2,
		arg3:       arg3,
		arg4:       arg4,
		arg5:       arg5,
		expected:   expected,
		expectOK:   expectOK,
	}
}

// GetterErrorTestCase is a generic test case for testing
// getter methods that return (V, error)
type GetterErrorTestCase[T any, V comparable] struct {
	name        string
	method      GetterErrorMethod[T, V]
	methodName  string
	item        *T
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorTestCase[T, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorTestCase[T, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorTestCase creates a new GetterErrorTestCase instance.
func NewGetterErrorTestCase[T any, V comparable](
	name string,
	method GetterErrorMethod[T, V],
	methodName string,
	item *T,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorTestCase[T, V] {
	return GetterErrorTestCase[T, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// GetterErrorOneArgTestCase is a generic test case for testing
// getter methods that return (V, error) with one argument
type GetterErrorOneArgTestCase[T, A1 any, V comparable] struct {
	name        string
	method      GetterErrorMethodOneArg[T, A1, V]
	methodName  string
	item        *T
	arg1        A1
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorOneArgTestCase[T, A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorOneArgTestCase[T, A1, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item, tc.arg1)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorOneArgTestCase creates a new GetterErrorOneArgTestCase instance.
func NewGetterErrorOneArgTestCase[T, A1 any, V comparable](
	name string,
	method GetterErrorMethodOneArg[T, A1, V],
	methodName string,
	item *T,
	arg1 A1,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorOneArgTestCase[T, A1, V] {
	return GetterErrorOneArgTestCase[T, A1, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// GetterErrorTwoArgsTestCase is a generic test case for testing
// getter methods that return (V, error) with two arguments
type GetterErrorTwoArgsTestCase[T, A1, A2 any, V comparable] struct {
	name        string
	method      GetterErrorMethodTwoArgs[T, A1, A2, V]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorTwoArgsTestCase[T, A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorTwoArgsTestCase[T, A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item, tc.arg1, tc.arg2)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorTwoArgsTestCase creates a new GetterErrorTwoArgsTestCase instance.
func NewGetterErrorTwoArgsTestCase[T, A1, A2 any, V comparable](
	name string,
	method GetterErrorMethodTwoArgs[T, A1, A2, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorTwoArgsTestCase[T, A1, A2, V] {
	return GetterErrorTwoArgsTestCase[T, A1, A2, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// GetterErrorThreeArgsTestCase is a generic test case for testing
// getter methods that return (V, error) with three arguments
type GetterErrorThreeArgsTestCase[T, A1, A2, A3 any, V comparable] struct {
	name        string
	method      GetterErrorMethodThreeArgs[T, A1, A2, A3, V]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorThreeArgsTestCase[T, A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorThreeArgsTestCase[T, A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorThreeArgsTestCase creates a new GetterErrorThreeArgsTestCase instance.
func NewGetterErrorThreeArgsTestCase[T, A1, A2, A3 any, V comparable](
	name string,
	method GetterErrorMethodThreeArgs[T, A1, A2, A3, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorThreeArgsTestCase[T, A1, A2, A3, V] {
	return GetterErrorThreeArgsTestCase[T, A1, A2, A3, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// GetterErrorFourArgsTestCase is a generic test case for testing
// getter methods that return (V, error) with four arguments
type GetterErrorFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable] struct {
	name        string
	method      GetterErrorMethodFourArgs[T, A1, A2, A3, A4, V]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorFourArgsTestCase[T, A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorFourArgsTestCase[T, A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorFourArgsTestCase creates a new GetterErrorFourArgsTestCase instance.
func NewGetterErrorFourArgsTestCase[T, A1, A2, A3, A4 any, V comparable](
	name string,
	method GetterErrorMethodFourArgs[T, A1, A2, A3, A4, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorFourArgsTestCase[T, A1, A2, A3, A4, V] {
	return GetterErrorFourArgsTestCase[T, A1, A2, A3, A4, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// GetterErrorFiveArgsTestCase is a generic test case for testing
// getter methods that return (V, error) with five arguments
type GetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable] struct {
	name        string
	method      GetterErrorMethodFiveArgs[T, A1, A2, A3, A4, A5, V]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	arg5        A5
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc GetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc GetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName+":error")
	}
}

// NewGetterErrorFiveArgsTestCase creates a new GetterErrorFiveArgsTestCase instance.
func NewGetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any, V comparable](
	name string,
	method GetterErrorMethodFiveArgs[T, A1, A2, A3, A4, A5, V],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
	expectError bool,
	errorIs error,
) GetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5, V] {
	return GetterErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5, V]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		arg5:        arg5,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorTestCase is a generic test case for testing
// methods that return error
type ErrorTestCase[T any] struct {
	name        string
	method      ErrorMethod[T]
	methodName  string
	item        *T
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorTestCase[T]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorTestCase[T]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorTestCase creates a new ErrorTestCase instance.
func NewErrorTestCase[T any](
	name string,
	method ErrorMethod[T],
	methodName string,
	item *T,
	expectError bool,
	errorIs error,
) ErrorTestCase[T] {
	return ErrorTestCase[T]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorOneArgTestCase is a generic test case for testing
// methods that return error with one argument
type ErrorOneArgTestCase[T, A1 any] struct {
	name        string
	method      ErrorMethodOneArg[T, A1]
	methodName  string
	item        *T
	arg1        A1
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorOneArgTestCase[T, A1]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorOneArgTestCase[T, A1]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item, tc.arg1)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorOneArgTestCase creates a new ErrorOneArgTestCase instance.
func NewErrorOneArgTestCase[T, A1 any](
	name string,
	method ErrorMethodOneArg[T, A1],
	methodName string,
	item *T,
	arg1 A1,
	expectError bool,
	errorIs error,
) ErrorOneArgTestCase[T, A1] {
	return ErrorOneArgTestCase[T, A1]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorTwoArgsTestCase is a generic test case for testing
// methods that return error with two arguments
type ErrorTwoArgsTestCase[T, A1, A2 any] struct {
	name        string
	method      ErrorMethodTwoArgs[T, A1, A2]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorTwoArgsTestCase[T, A1, A2]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorTwoArgsTestCase[T, A1, A2]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item, tc.arg1, tc.arg2)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorTwoArgsTestCase creates a new ErrorTwoArgsTestCase instance.
func NewErrorTwoArgsTestCase[T, A1, A2 any](
	name string,
	method ErrorMethodTwoArgs[T, A1, A2],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	expectError bool,
	errorIs error,
) ErrorTwoArgsTestCase[T, A1, A2] {
	return ErrorTwoArgsTestCase[T, A1, A2]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorThreeArgsTestCase is a generic test case for testing
// methods that return error with three arguments
type ErrorThreeArgsTestCase[T, A1, A2, A3 any] struct {
	name        string
	method      ErrorMethodThreeArgs[T, A1, A2, A3]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorThreeArgsTestCase[T, A1, A2, A3]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorThreeArgsTestCase[T, A1, A2, A3]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorThreeArgsTestCase creates a new ErrorThreeArgsTestCase instance.
func NewErrorThreeArgsTestCase[T, A1, A2, A3 any](
	name string,
	method ErrorMethodThreeArgs[T, A1, A2, A3],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expectError bool,
	errorIs error,
) ErrorThreeArgsTestCase[T, A1, A2, A3] {
	return ErrorThreeArgsTestCase[T, A1, A2, A3]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorFourArgsTestCase is a generic test case for testing
// methods that return error with four arguments
type ErrorFourArgsTestCase[T, A1, A2, A3, A4 any] struct {
	name        string
	method      ErrorMethodFourArgs[T, A1, A2, A3, A4]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorFourArgsTestCase[T, A1, A2, A3, A4]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorFourArgsTestCase[T, A1, A2, A3, A4]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorFourArgsTestCase creates a new ErrorFourArgsTestCase instance.
func NewErrorFourArgsTestCase[T, A1, A2, A3, A4 any](
	name string,
	method ErrorMethodFourArgs[T, A1, A2, A3, A4],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expectError bool,
	errorIs error,
) ErrorFourArgsTestCase[T, A1, A2, A3, A4] {
	return ErrorFourArgsTestCase[T, A1, A2, A3, A4]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// ErrorFiveArgsTestCase is a generic test case for testing
// methods that return error with five arguments
type ErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any] struct {
	name        string
	method      ErrorMethodFiveArgs[T, A1, A2, A3, A4, A5]
	methodName  string
	item        *T
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	arg5        A5
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc ErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc ErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Test(t *testing.T) {
	t.Helper()
	err := tc.method(tc.item, tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.methodName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.methodName)
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.methodName)
	}
}

// NewErrorFiveArgsTestCase creates a new ErrorFiveArgsTestCase instance.
func NewErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any](
	name string,
	method ErrorMethodFiveArgs[T, A1, A2, A3, A4, A5],
	methodName string,
	item *T,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expectError bool,
	errorIs error,
) ErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5] {
	return ErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]{
		name:        name,
		method:      method,
		methodName:  methodName,
		item:        item,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		arg5:        arg5,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FactoryTestCase is a generic test case for testing
// factory functions that return *T
type FactoryTestCase[T any] struct {
	name      string
	fn        Factory[T]
	funcName  string
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryTestCase[T]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryTestCase[T]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn()
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryTestCase creates a new FactoryTestCase instance.
func NewFactoryTestCase[T any](
	name string,
	fn Factory[T],
	funcName string,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryTestCase[T] {
	return FactoryTestCase[T]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryOneArgTestCase is a generic test case for testing
// factory functions that return *T with one argument
type FactoryOneArgTestCase[T, A1 any] struct {
	name      string
	fn        FactoryOneArg[T, A1]
	funcName  string
	arg1      A1
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOneArgTestCase[T, A1]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOneArgTestCase[T, A1]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn(tc.arg1)
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOneArgTestCase creates a new FactoryOneArgTestCase instance.
func NewFactoryOneArgTestCase[T, A1 any](
	name string,
	fn FactoryOneArg[T, A1],
	funcName string,
	arg1 A1,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryOneArgTestCase[T, A1] {
	return FactoryOneArgTestCase[T, A1]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		arg1:      arg1,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryTwoArgsTestCase is a generic test case for testing
// factory functions that return *T with two arguments
type FactoryTwoArgsTestCase[T, A1, A2 any] struct {
	name      string
	fn        FactoryTwoArgs[T, A1, A2]
	funcName  string
	arg1      A1
	arg2      A2
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryTwoArgsTestCase[T, A1, A2]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryTwoArgsTestCase[T, A1, A2]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn(tc.arg1, tc.arg2)
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryTwoArgsTestCase creates a new FactoryTwoArgsTestCase instance.
func NewFactoryTwoArgsTestCase[T, A1, A2 any](
	name string,
	fn FactoryTwoArgs[T, A1, A2],
	funcName string,
	arg1 A1,
	arg2 A2,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryTwoArgsTestCase[T, A1, A2] {
	return FactoryTwoArgsTestCase[T, A1, A2]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		arg1:      arg1,
		arg2:      arg2,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryThreeArgsTestCase is a generic test case for testing
// factory functions that return *T with three arguments
type FactoryThreeArgsTestCase[T, A1, A2, A3 any] struct {
	name      string
	fn        FactoryThreeArgs[T, A1, A2, A3]
	funcName  string
	arg1      A1
	arg2      A2
	arg3      A3
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryThreeArgsTestCase[T, A1, A2, A3]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryThreeArgsTestCase[T, A1, A2, A3]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryThreeArgsTestCase creates a new FactoryThreeArgsTestCase instance.
func NewFactoryThreeArgsTestCase[T, A1, A2, A3 any](
	name string,
	fn FactoryThreeArgs[T, A1, A2, A3],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryThreeArgsTestCase[T, A1, A2, A3] {
	return FactoryThreeArgsTestCase[T, A1, A2, A3]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		arg1:      arg1,
		arg2:      arg2,
		arg3:      arg3,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryFourArgsTestCase is a generic test case for testing
// factory functions that return *T with four arguments
type FactoryFourArgsTestCase[T, A1, A2, A3, A4 any] struct {
	name      string
	fn        FactoryFourArgs[T, A1, A2, A3, A4]
	funcName  string
	arg1      A1
	arg2      A2
	arg3      A3
	arg4      A4
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryFourArgsTestCase[T, A1, A2, A3, A4]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryFourArgsTestCase[T, A1, A2, A3, A4]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryFourArgsTestCase creates a new FactoryFourArgsTestCase instance.
func NewFactoryFourArgsTestCase[T, A1, A2, A3, A4 any](
	name string,
	fn FactoryFourArgs[T, A1, A2, A3, A4],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryFourArgsTestCase[T, A1, A2, A3, A4] {
	return FactoryFourArgsTestCase[T, A1, A2, A3, A4]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		arg1:      arg1,
		arg2:      arg2,
		arg3:      arg3,
		arg4:      arg4,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryFiveArgsTestCase is a generic test case for testing
// factory functions that return *T with five arguments
type FactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5 any] struct {
	name      string
	fn        FactoryFiveArgs[T, A1, A2, A3, A4, A5]
	funcName  string
	arg1      A1
	arg2      A2
	arg3      A3
	arg4      A4
	arg5      A5
	expectNil bool
	typeTest  TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Test(t *testing.T) {
	t.Helper()
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	if tc.expectNil {
		core.AssertNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryFiveArgsTestCase creates a new FactoryFiveArgsTestCase instance.
func NewFactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5 any](
	name string,
	fn FactoryFiveArgs[T, A1, A2, A3, A4, A5],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expectNil bool,
	typeTest TypeTestFunc[T],
) FactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5] {
	return FactoryFiveArgsTestCase[T, A1, A2, A3, A4, A5]{
		name:      name,
		fn:        fn,
		funcName:  funcName,
		arg1:      arg1,
		arg2:      arg2,
		arg3:      arg3,
		arg4:      arg4,
		arg5:      arg5,
		expectNil: expectNil,
		typeTest:  typeTest,
	}
}

// FactoryOKTestCase is a generic test case for testing
// factory functions that return (*T, bool)
type FactoryOKTestCase[T any] struct {
	name     string
	fn       FactoryOK[T]
	funcName string
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKTestCase[T]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKTestCase[T]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn()
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKTestCase creates a new FactoryOKTestCase instance.
func NewFactoryOKTestCase[T any](
	name string,
	fn FactoryOK[T],
	funcName string,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKTestCase[T] {
	return FactoryOKTestCase[T]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryOKOneArgTestCase is a generic test case for testing
// factory functions that return (*T, bool) with one argument
type FactoryOKOneArgTestCase[T, A1 any] struct {
	name     string
	fn       FactoryOKOneArg[T, A1]
	funcName string
	arg1     A1
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKOneArgTestCase[T, A1]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKOneArgTestCase[T, A1]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKOneArgTestCase creates a new FactoryOKOneArgTestCase instance.
func NewFactoryOKOneArgTestCase[T, A1 any](
	name string,
	fn FactoryOKOneArg[T, A1],
	funcName string,
	arg1 A1,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKOneArgTestCase[T, A1] {
	return FactoryOKOneArgTestCase[T, A1]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryOKTwoArgsTestCase is a generic test case for testing
// factory functions that return (*T, bool) with two arguments
type FactoryOKTwoArgsTestCase[T, A1, A2 any] struct {
	name     string
	fn       FactoryOKTwoArgs[T, A1, A2]
	funcName string
	arg1     A1
	arg2     A2
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKTwoArgsTestCase[T, A1, A2]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKTwoArgsTestCase[T, A1, A2]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKTwoArgsTestCase creates a new FactoryOKTwoArgsTestCase instance.
func NewFactoryOKTwoArgsTestCase[T, A1, A2 any](
	name string,
	fn FactoryOKTwoArgs[T, A1, A2],
	funcName string,
	arg1 A1,
	arg2 A2,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKTwoArgsTestCase[T, A1, A2] {
	return FactoryOKTwoArgsTestCase[T, A1, A2]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryOKThreeArgsTestCase is a generic test case for testing
// factory functions that return (*T, bool) with three arguments
type FactoryOKThreeArgsTestCase[T, A1, A2, A3 any] struct {
	name     string
	fn       FactoryOKThreeArgs[T, A1, A2, A3]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKThreeArgsTestCase[T, A1, A2, A3]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKThreeArgsTestCase[T, A1, A2, A3]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKThreeArgsTestCase creates a new FactoryOKThreeArgsTestCase instance.
func NewFactoryOKThreeArgsTestCase[T, A1, A2, A3 any](
	name string,
	fn FactoryOKThreeArgs[T, A1, A2, A3],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKThreeArgsTestCase[T, A1, A2, A3] {
	return FactoryOKThreeArgsTestCase[T, A1, A2, A3]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryOKFourArgsTestCase is a generic test case for testing
// factory functions that return (*T, bool) with four arguments
type FactoryOKFourArgsTestCase[T, A1, A2, A3, A4 any] struct {
	name     string
	fn       FactoryOKFourArgs[T, A1, A2, A3, A4]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKFourArgsTestCase[T, A1, A2, A3, A4]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKFourArgsTestCase[T, A1, A2, A3, A4]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKFourArgsTestCase creates a new FactoryOKFourArgsTestCase instance.
func NewFactoryOKFourArgsTestCase[T, A1, A2, A3, A4 any](
	name string,
	fn FactoryOKFourArgs[T, A1, A2, A3, A4],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKFourArgsTestCase[T, A1, A2, A3, A4] {
	return FactoryOKFourArgsTestCase[T, A1, A2, A3, A4]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryOKFiveArgsTestCase is a generic test case for testing
// factory functions that return (*T, bool) with five arguments
type FactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5 any] struct {
	name     string
	fn       FactoryOKFiveArgs[T, A1, A2, A3, A4, A5]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	arg5     A5
	expectOK bool
	typeTest TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if !tc.expectOK {
		core.AssertMustNil(t, actual, tc.funcName)
		return
	}

	core.AssertMustNotNil(t, actual, tc.funcName)
	if tc.typeTest != nil {
		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	}
}

// NewFactoryOKFiveArgsTestCase creates a new FactoryOKFiveArgsTestCase instance.
func NewFactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5 any](
	name string,
	fn FactoryOKFiveArgs[T, A1, A2, A3, A4, A5],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expectOK bool,
	typeTest TypeTestFunc[T],
) FactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5] {
	return FactoryOKFiveArgsTestCase[T, A1, A2, A3, A4, A5]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		arg5:     arg5,
		expectOK: expectOK,
		typeTest: typeTest,
	}
}

// FactoryErrorTestCase is a generic test case for testing
// factory functions that return (*T, error)
type FactoryErrorTestCase[T any] struct {
	name        string
	fn          FactoryError[T]
	funcName    string
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorTestCase[T]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorTestCase[T]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn()
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorTestCase creates a new FactoryErrorTestCase instance.
func NewFactoryErrorTestCase[T any](
	name string,
	fn FactoryError[T],
	funcName string,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorTestCase[T] {
	return FactoryErrorTestCase[T]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FactoryErrorOneArgTestCase is a generic test case for testing
// factory functions that return (*T, error) with one argument
type FactoryErrorOneArgTestCase[T, A1 any] struct {
	name        string
	fn          FactoryErrorOneArg[T, A1]
	funcName    string
	arg1        A1
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorOneArgTestCase[T, A1]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorOneArgTestCase[T, A1]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorOneArgTestCase creates a new FactoryErrorOneArgTestCase instance.
func NewFactoryErrorOneArgTestCase[T, A1 any](
	name string,
	fn FactoryErrorOneArg[T, A1],
	funcName string,
	arg1 A1,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorOneArgTestCase[T, A1] {
	return FactoryErrorOneArgTestCase[T, A1]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FactoryErrorTwoArgsTestCase is a generic test case for testing
// factory functions that return (*T, error) with two arguments
type FactoryErrorTwoArgsTestCase[T, A1, A2 any] struct {
	name        string
	fn          FactoryErrorTwoArgs[T, A1, A2]
	funcName    string
	arg1        A1
	arg2        A2
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorTwoArgsTestCase[T, A1, A2]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorTwoArgsTestCase[T, A1, A2]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorTwoArgsTestCase creates a new FactoryErrorTwoArgsTestCase instance.
func NewFactoryErrorTwoArgsTestCase[T, A1, A2 any](
	name string,
	fn FactoryErrorTwoArgs[T, A1, A2],
	funcName string,
	arg1 A1,
	arg2 A2,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorTwoArgsTestCase[T, A1, A2] {
	return FactoryErrorTwoArgsTestCase[T, A1, A2]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FactoryErrorThreeArgsTestCase is a generic test case for testing
// factory functions that return (*T, error) with three arguments
type FactoryErrorThreeArgsTestCase[T, A1, A2, A3 any] struct {
	name        string
	fn          FactoryErrorThreeArgs[T, A1, A2, A3]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorThreeArgsTestCase[T, A1, A2, A3]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorThreeArgsTestCase[T, A1, A2, A3]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorThreeArgsTestCase creates a new FactoryErrorThreeArgsTestCase instance.
func NewFactoryErrorThreeArgsTestCase[T, A1, A2, A3 any](
	name string,
	fn FactoryErrorThreeArgs[T, A1, A2, A3],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorThreeArgsTestCase[T, A1, A2, A3] {
	return FactoryErrorThreeArgsTestCase[T, A1, A2, A3]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FactoryErrorFourArgsTestCase is a generic test case for testing
// factory functions that return (*T, error) with four arguments
type FactoryErrorFourArgsTestCase[T, A1, A2, A3, A4 any] struct {
	name        string
	fn          FactoryErrorFourArgs[T, A1, A2, A3, A4]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorFourArgsTestCase[T, A1, A2, A3, A4]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorFourArgsTestCase[T, A1, A2, A3, A4]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorFourArgsTestCase creates a new FactoryErrorFourArgsTestCase instance.
func NewFactoryErrorFourArgsTestCase[T, A1, A2, A3, A4 any](
	name string,
	fn FactoryErrorFourArgs[T, A1, A2, A3, A4],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorFourArgsTestCase[T, A1, A2, A3, A4] {
	return FactoryErrorFourArgsTestCase[T, A1, A2, A3, A4]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FactoryErrorFiveArgsTestCase is a generic test case for testing
// factory functions that return (*T, error) with five arguments
type FactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any] struct {
	name        string
	fn          FactoryErrorFiveArgs[T, A1, A2, A3, A4, A5]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	arg5        A5
	expectError bool
	errorIs     error
	typeTest    TypeTestFunc[T]
}

// Name returns the test case name.
func (tc FactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName)
		core.AssertMustNotNil(t, actual, tc.funcName)
		if tc.typeTest == nil {
			return
		}

		valid := tc.typeTest(t, actual)
		core.AssertTrue(t, valid, tc.funcName+":valid")
	case tc.errorIs == nil:
		core.AssertMustError(t, err, tc.funcName)
	default:
		core.AssertErrorIs(t, err, tc.errorIs, tc.funcName+":type")
	}
}

// NewFactoryErrorFiveArgsTestCase creates a new FactoryErrorFiveArgsTestCase instance.
func NewFactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5 any](
	name string,
	fn FactoryErrorFiveArgs[T, A1, A2, A3, A4, A5],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expectError bool,
	errorIs error,
	typeTest TypeTestFunc[T],
) FactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5] {
	return FactoryErrorFiveArgsTestCase[T, A1, A2, A3, A4, A5]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		arg5:        arg5,
		expectError: expectError,
		errorIs:     errorIs,
		typeTest:    typeTest,
	}
}

// FunctionTestCase is a generic test case for testing
// functions that return V
type FunctionTestCase[V comparable] struct {
	name     string
	fn       Function[V]
	funcName string
	expected V
}

// Name returns the test case name.
func (tc FunctionTestCase[V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionTestCase[V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn()
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionTestCase creates a new FunctionTestCase instance.
func NewFunctionTestCase[V comparable](
	name string,
	fn Function[V],
	funcName string,
	expected V,
) FunctionTestCase[V] {
	return FunctionTestCase[V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		expected: expected,
	}
}

// FunctionOneArgTestCase is a generic test case for testing
// functions that return V with one argument
type FunctionOneArgTestCase[A1 any, V comparable] struct {
	name     string
	fn       FunctionOneArg[A1, V]
	funcName string
	arg1     A1
	expected V
}

// Name returns the test case name.
func (tc FunctionOneArgTestCase[A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOneArgTestCase[A1, V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn(tc.arg1)
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionOneArgTestCase creates a new FunctionOneArgTestCase instance.
func NewFunctionOneArgTestCase[A1 any, V comparable](
	name string,
	fn FunctionOneArg[A1, V],
	funcName string,
	arg1 A1,
	expected V,
) FunctionOneArgTestCase[A1, V] {
	return FunctionOneArgTestCase[A1, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		expected: expected,
	}
}

// FunctionTwoArgsTestCase is a generic test case for testing
// functions that return V with two arguments
type FunctionTwoArgsTestCase[A1, A2 any, V comparable] struct {
	name     string
	fn       FunctionTwoArgs[A1, A2, V]
	funcName string
	arg1     A1
	arg2     A2
	expected V
}

// Name returns the test case name.
func (tc FunctionTwoArgsTestCase[A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionTwoArgsTestCase[A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn(tc.arg1, tc.arg2)
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionTwoArgsTestCase creates a new FunctionTwoArgsTestCase instance.
func NewFunctionTwoArgsTestCase[A1, A2 any, V comparable](
	name string,
	fn FunctionTwoArgs[A1, A2, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	expected V,
) FunctionTwoArgsTestCase[A1, A2, V] {
	return FunctionTwoArgsTestCase[A1, A2, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		expected: expected,
	}
}

// FunctionThreeArgsTestCase is a generic test case for testing
// functions that return V with three arguments
type FunctionThreeArgsTestCase[A1, A2, A3 any, V comparable] struct {
	name     string
	fn       FunctionThreeArgs[A1, A2, A3, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	expected V
}

// Name returns the test case name.
func (tc FunctionThreeArgsTestCase[A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionThreeArgsTestCase[A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionThreeArgsTestCase creates a new FunctionThreeArgsTestCase instance.
func NewFunctionThreeArgsTestCase[A1, A2, A3 any, V comparable](
	name string,
	fn FunctionThreeArgs[A1, A2, A3, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
) FunctionThreeArgsTestCase[A1, A2, A3, V] {
	return FunctionThreeArgsTestCase[A1, A2, A3, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		expected: expected,
	}
}

// FunctionFourArgsTestCase is a generic test case for testing
// functions that return V with four arguments
type FunctionFourArgsTestCase[A1, A2, A3, A4 any, V comparable] struct {
	name     string
	fn       FunctionFourArgs[A1, A2, A3, A4, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	expected V
}

// Name returns the test case name.
func (tc FunctionFourArgsTestCase[A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionFourArgsTestCase[A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionFourArgsTestCase creates a new FunctionFourArgsTestCase instance.
func NewFunctionFourArgsTestCase[A1, A2, A3, A4 any, V comparable](
	name string,
	fn FunctionFourArgs[A1, A2, A3, A4, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
) FunctionFourArgsTestCase[A1, A2, A3, A4, V] {
	return FunctionFourArgsTestCase[A1, A2, A3, A4, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		expected: expected,
	}
}

// FunctionFiveArgsTestCase is a generic test case for testing
// functions that return V with five arguments
type FunctionFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable] struct {
	name     string
	fn       FunctionFiveArgs[A1, A2, A3, A4, A5, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	arg5     A5
	expected V
}

// Name returns the test case name.
func (tc FunctionFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	core.AssertMustNotNil(t, tc.fn, tc.funcName+":function")
	actual := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	core.AssertEqual(t, tc.expected, actual, tc.funcName)
}

// NewFunctionFiveArgsTestCase creates a new FunctionFiveArgsTestCase instance.
func NewFunctionFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable](
	name string,
	fn FunctionFiveArgs[A1, A2, A3, A4, A5, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
) FunctionFiveArgsTestCase[A1, A2, A3, A4, A5, V] {
	return FunctionFiveArgsTestCase[A1, A2, A3, A4, A5, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		arg5:     arg5,
		expected: expected,
	}
}

// FunctionOKTestCase is a generic test case for testing
// functions that return (V, bool)
type FunctionOKTestCase[V comparable] struct {
	name     string
	fn       FunctionOK[V]
	funcName string
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKTestCase[V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKTestCase[V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn()
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKTestCase creates a new FunctionOKTestCase instance.
func NewFunctionOKTestCase[V comparable](
	name string,
	fn FunctionOK[V],
	funcName string,
	expected V,
	expectOK bool,
) FunctionOKTestCase[V] {
	return FunctionOKTestCase[V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionOKOneArgTestCase is a generic test case for testing
// functions that return (V, bool) with one argument
type FunctionOKOneArgTestCase[A1 any, V comparable] struct {
	name     string
	fn       FunctionOKOneArg[A1, V]
	funcName string
	arg1     A1
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKOneArgTestCase[A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKOneArgTestCase[A1, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKOneArgTestCase creates a new FunctionOKOneArgTestCase instance.
func NewFunctionOKOneArgTestCase[A1 any, V comparable](
	name string,
	fn FunctionOKOneArg[A1, V],
	funcName string,
	arg1 A1,
	expected V,
	expectOK bool,
) FunctionOKOneArgTestCase[A1, V] {
	return FunctionOKOneArgTestCase[A1, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionOKTwoArgsTestCase is a generic test case for testing
// functions that return (V, bool) with two arguments
type FunctionOKTwoArgsTestCase[A1, A2 any, V comparable] struct {
	name     string
	fn       FunctionOKTwoArgs[A1, A2, V]
	funcName string
	arg1     A1
	arg2     A2
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKTwoArgsTestCase[A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKTwoArgsTestCase[A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKTwoArgsTestCase creates a new FunctionOKTwoArgsTestCase instance.
func NewFunctionOKTwoArgsTestCase[A1, A2 any, V comparable](
	name string,
	fn FunctionOKTwoArgs[A1, A2, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	expected V,
	expectOK bool,
) FunctionOKTwoArgsTestCase[A1, A2, V] {
	return FunctionOKTwoArgsTestCase[A1, A2, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionOKThreeArgsTestCase is a generic test case for testing
// functions that return (V, bool) with three arguments
type FunctionOKThreeArgsTestCase[A1, A2, A3 any, V comparable] struct {
	name     string
	fn       FunctionOKThreeArgs[A1, A2, A3, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKThreeArgsTestCase[A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKThreeArgsTestCase[A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKThreeArgsTestCase creates a new FunctionOKThreeArgsTestCase instance.
func NewFunctionOKThreeArgsTestCase[A1, A2, A3 any, V comparable](
	name string,
	fn FunctionOKThreeArgs[A1, A2, A3, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
	expectOK bool,
) FunctionOKThreeArgsTestCase[A1, A2, A3, V] {
	return FunctionOKThreeArgsTestCase[A1, A2, A3, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionOKFourArgsTestCase is a generic test case for testing
// functions that return (V, bool) with four arguments
type FunctionOKFourArgsTestCase[A1, A2, A3, A4 any, V comparable] struct {
	name     string
	fn       FunctionOKFourArgs[A1, A2, A3, A4, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKFourArgsTestCase[A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKFourArgsTestCase[A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKFourArgsTestCase creates a new FunctionOKFourArgsTestCase instance.
func NewFunctionOKFourArgsTestCase[A1, A2, A3, A4 any, V comparable](
	name string,
	fn FunctionOKFourArgs[A1, A2, A3, A4, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
	expectOK bool,
) FunctionOKFourArgsTestCase[A1, A2, A3, A4, V] {
	return FunctionOKFourArgsTestCase[A1, A2, A3, A4, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionOKFiveArgsTestCase is a generic test case for testing
// functions that return (V, bool) with five arguments
type FunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable] struct {
	name     string
	fn       FunctionOKFiveArgs[A1, A2, A3, A4, A5, V]
	funcName string
	arg1     A1
	arg2     A2
	arg3     A3
	arg4     A4
	arg5     A5
	expected V
	expectOK bool
}

// Name returns the test case name.
func (tc FunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	actual, ok := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	core.AssertEqual(t, tc.expectOK, ok, tc.funcName+":ok")
	if tc.expectOK {
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	}
}

// NewFunctionOKFiveArgsTestCase creates a new FunctionOKFiveArgsTestCase instance.
func NewFunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable](
	name string,
	fn FunctionOKFiveArgs[A1, A2, A3, A4, A5, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
	expectOK bool,
) FunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5, V] {
	return FunctionOKFiveArgsTestCase[A1, A2, A3, A4, A5, V]{
		name:     name,
		fn:       fn,
		funcName: funcName,
		arg1:     arg1,
		arg2:     arg2,
		arg3:     arg3,
		arg4:     arg4,
		arg5:     arg5,
		expected: expected,
		expectOK: expectOK,
	}
}

// FunctionErrorTestCase is a generic test case for testing
// functions that return (V, error)
type FunctionErrorTestCase[V comparable] struct {
	name        string
	fn          FunctionError[V]
	funcName    string
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorTestCase[V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorTestCase[V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn()
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorTestCase creates a new FunctionErrorTestCase instance.
func NewFunctionErrorTestCase[V comparable](
	name string,
	fn FunctionError[V],
	funcName string,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorTestCase[V] {
	return FunctionErrorTestCase[V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FunctionErrorOneArgTestCase is a generic test case for testing
// functions that return (V, error) with one argument
type FunctionErrorOneArgTestCase[A1 any, V comparable] struct {
	name        string
	fn          FunctionErrorOneArg[A1, V]
	funcName    string
	arg1        A1
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorOneArgTestCase[A1, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorOneArgTestCase[A1, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorOneArgTestCase creates a new FunctionErrorOneArgTestCase instance.
func NewFunctionErrorOneArgTestCase[A1 any, V comparable](
	name string,
	fn FunctionErrorOneArg[A1, V],
	funcName string,
	arg1 A1,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorOneArgTestCase[A1, V] {
	return FunctionErrorOneArgTestCase[A1, V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FunctionErrorTwoArgsTestCase is a generic test case for testing
// functions that return (V, error) with two arguments
type FunctionErrorTwoArgsTestCase[A1, A2 any, V comparable] struct {
	name        string
	fn          FunctionErrorTwoArgs[A1, A2, V]
	funcName    string
	arg1        A1
	arg2        A2
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorTwoArgsTestCase[A1, A2, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorTwoArgsTestCase[A1, A2, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorTwoArgsTestCase creates a new FunctionErrorTwoArgsTestCase instance.
func NewFunctionErrorTwoArgsTestCase[A1, A2 any, V comparable](
	name string,
	fn FunctionErrorTwoArgs[A1, A2, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorTwoArgsTestCase[A1, A2, V] {
	return FunctionErrorTwoArgsTestCase[A1, A2, V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FunctionErrorThreeArgsTestCase is a generic test case for testing
// functions that return (V, error) with three arguments
type FunctionErrorThreeArgsTestCase[A1, A2, A3 any, V comparable] struct {
	name        string
	fn          FunctionErrorThreeArgs[A1, A2, A3, V]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorThreeArgsTestCase[A1, A2, A3, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorThreeArgsTestCase[A1, A2, A3, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorThreeArgsTestCase creates a new FunctionErrorThreeArgsTestCase instance.
func NewFunctionErrorThreeArgsTestCase[A1, A2, A3 any, V comparable](
	name string,
	fn FunctionErrorThreeArgs[A1, A2, A3, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorThreeArgsTestCase[A1, A2, A3, V] {
	return FunctionErrorThreeArgsTestCase[A1, A2, A3, V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FunctionErrorFourArgsTestCase is a generic test case for testing
// functions that return (V, error) with four arguments
type FunctionErrorFourArgsTestCase[A1, A2, A3, A4 any, V comparable] struct {
	name        string
	fn          FunctionErrorFourArgs[A1, A2, A3, A4, V]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorFourArgsTestCase[A1, A2, A3, A4, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorFourArgsTestCase[A1, A2, A3, A4, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorFourArgsTestCase creates a new FunctionErrorFourArgsTestCase instance.
func NewFunctionErrorFourArgsTestCase[A1, A2, A3, A4 any, V comparable](
	name string,
	fn FunctionErrorFourArgs[A1, A2, A3, A4, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorFourArgsTestCase[A1, A2, A3, A4, V] {
	return FunctionErrorFourArgsTestCase[A1, A2, A3, A4, V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}

// FunctionErrorFiveArgsTestCase is a generic test case for testing
// functions that return (V, error) with five arguments
type FunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable] struct {
	name        string
	fn          FunctionErrorFiveArgs[A1, A2, A3, A4, A5, V]
	funcName    string
	arg1        A1
	arg2        A2
	arg3        A3
	arg4        A4
	arg5        A5
	expected    V
	expectError bool
	errorIs     error
}

// Name returns the test case name.
func (tc FunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Name() string {
	return tc.name
}

// Test executes the test case.
func (tc FunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5, V]) Test(t *testing.T) {
	t.Helper()
	actual, err := tc.fn(tc.arg1, tc.arg2, tc.arg3, tc.arg4, tc.arg5)
	switch {
	case !tc.expectError:
		core.AssertNoError(t, err, tc.funcName+":error")
		core.AssertEqual(t, tc.expected, actual, tc.funcName)
	case tc.errorIs == nil:
		core.AssertError(t, err, tc.funcName+":error")
	default:
		core.AssertErrorIs(t, tc.errorIs, err, tc.funcName+":error")
	}
}

// NewFunctionErrorFiveArgsTestCase creates a new FunctionErrorFiveArgsTestCase instance.
func NewFunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5 any, V comparable](
	name string,
	fn FunctionErrorFiveArgs[A1, A2, A3, A4, A5, V],
	funcName string,
	arg1 A1,
	arg2 A2,
	arg3 A3,
	arg4 A4,
	arg5 A5,
	expected V,
	expectError bool,
	errorIs error,
) FunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5, V] {
	return FunctionErrorFiveArgsTestCase[A1, A2, A3, A4, A5, V]{
		name:        name,
		fn:          fn,
		funcName:    funcName,
		arg1:        arg1,
		arg2:        arg2,
		arg3:        arg3,
		arg4:        arg4,
		arg5:        arg5,
		expected:    expected,
		expectError: expectError,
		errorIs:     errorIs,
	}
}
